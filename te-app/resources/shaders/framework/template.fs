#version 410

#define MAX_PALETTE_ENTRIES 5

out vec4 finalColor;

// shared uniforms that are set once per run
layout (std140) uniform PerRunBlock {
  vec4 iMouse;
  vec2 iResolution;
};

// shared uniforms that are set once per frame
layout (std140) uniform PerFrameBlock {
// Legacy TE Audio uniforms
    uniform float beat;
    uniform float sinPhaseBeat;
    uniform float bassLevel;
    uniform float trebleLevel;

    uniform float volumeRatio;
    uniform float bassRatio;
    uniform float trebleRatio;

// Values from audio stem splitter
    uniform float stemBass;
    uniform float stemDrums;
    uniform float stemVocals;
    uniform float stemOther;
    uniform float stemDrumHits;

// Palette uniforms
    uniform float iPaletteSize; // number of active entries in the palette
    uniform vec3[MAX_PALETTE_ENTRIES] iPalette;
};

// standard shadertoy uniforms (updated per frame for each
// running pattern.)
uniform float iTime;

// TE Colors
uniform vec3 iColorRGB;
uniform vec3 iColorHSB;
uniform vec3 iColor2RGB;
uniform vec3 iColor2HSB;
uniform float iPaletteOffset;

// TE common controls
uniform float iSpeed;
uniform float iScale;
uniform float iQuantity;
uniform vec2 iTranslate;
uniform float iSpin;
uniform float iRotationAngle;
uniform float iBrightness;
uniform float iWow1;
uniform float iWow2;
uniform bool iWowTrigger;
uniform float frequencyReact;
uniform float levelReact;

// Shadertoy audio channel
uniform sampler2D iChannel0;

// Normalized model coordinates
uniform sampler2D lxModelCoords;

// Buffer containing frame generated by previous shader
uniform sampler2D iBackbuffer;
uniform sampler2D lxModelIndex;

// Optional user defined textures
uniform sampler2D iChannel1;
uniform sampler2D iChannel2;
uniform sampler2D iChannel3;

// returns the normalized model coordinates for the current fragment
vec4 _getModelCoordinates() {
    return texelFetch(lxModelCoords, ivec2(gl_FragCoord.xy), 0);
}

// returns the color of the current fragment in the backbuffer
vec4 _getBackbufferPixel() {
    return texelFetch(iBackbuffer, ivec2(gl_FragCoord.xy), 0);
}

// Returns the color of the specified backbuffer pixel given 2d coordinates.
vec4 _getMappedPixel(sampler2D tex, ivec2 coords) {
    // get location of actual model pixel from the index map texture
    vec2 mapCoords = texelFetch(lxModelIndex, coords, 0).rg;
    // If coordinates point to an unmapped pixel, return black.
    if (isnan(mapCoords.r)) {
        return vec4(0.0);
    }
    return texelFetch(tex, ivec2(mapCoords), 0);
}

#line 1
{{%shader_body%}}

vec4 _blendFix(vec4 col) {
  /*
     if alpha is exactly 1.0, it has probably been deliberately clamped there, so
     we will fix it to improve blending by making a 1:1 substitution
     of brightness for alpha.

     Note that while this works perfectly for colors on a black
     background, the blending process may reduce the visibility of dimmer colors
     on more complex backgrounds.

     If this presents a problem for a particular shader, define TE_ALPHATHRESHOLD in the
     shader to set a brightness threshold above which colors will be fully opaque (alpha == 1.0).
     Colors below this threshold will be blended with brightness-derived alpha as usual.
   */
    if (col.a == 1.0) {
        col.rgb = clamp(col.rgb,0.0, 1.0);

        // use the maximum color value as alpha.
        col.a = max(col.r,max(col.g, col.b));

        #ifdef TE_ALPHATHRESHOLD
        // make colors with brightness above the threshold fully opaque
        if (col.a >= TE_ALPHATHRESHOLD) col.a = 1.0;
        #endif

        // use alpha value to set the brightness of the rgb components
        // if alpha is 1.0, brightness will not be changed, otherwise, the
        // color will become the brightest possible version of itself.
        col.rgb = col.rgb / col.a;
    }
    return col;
}

void main() {
    vec2 coords = _getModelCoordinates().xy;
    // NaN value signals the end of valid coordinates
    // We can use this to avoid doing work for points that
    // are not part of the current view.
    if (isnan(coords.r)) {
        finalColor = vec4(0.0);
        return;
    }

    // Scale the coordinates to the resolution specified by Chromatik
    // (which can be changed via the --resolution command line option)
    coords *= iResolution;

    // translate according to XPos and YPos controls unless explicitly overriden
    #ifndef TE_NOTRANSLATE
    mainImage(finalColor, coords-(iTranslate * iResolution));
    #else
    mainImage(finalColor, coords);
    #endif

    // Post-processing: Make sure we've got optimal color and alpha values for brightness
    // and blending. define TE_NOALPHAFIX in your shader code if you need
    // the 2023 pre-EDC blending behavior. Define TE_NOPOSTPROCESSING if you
    // want the unmodified shader output.
    #ifndef TE_NOPOSTPROCESSING
    #ifndef TE_NOALPHAFIX
    finalColor = _blendFix(finalColor);
    #else
    // Old EDC blending - force black pixels to full transparency, otherwise
    // use shader provided alpha
    finalColor.a = ((finalColor.r + finalColor.g + finalColor.b) == 0.0) ? 0.0 : finalColor.a;
    #endif
    #endif
}
